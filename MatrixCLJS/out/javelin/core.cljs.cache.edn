{:rename-macros {}, :renames {}, :externs {Error {}, Array {prototype {slice {call {}}}}}, :use-macros {}, :excludes #{}, :name javelin.core, :imports nil, :requires {garray goog.array, goog.array goog.array, gobj goog.object, goog.object goog.object}, :cljs.spec/speced-vars [], :uses nil, :defs {->Cell {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 104, :column 10, :end-line 104, :end-column 14, :protocols #{cljs.core/IWatchable cljs.core/IReset cljs.core/ISwap cljs.core/IMeta cljs.core/IDeref cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IReset cljs.core/ISwap cljs.core/IMeta cljs.core/IDeref cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([meta state rank prev sources sinks thunk watches update constant numwatches]))}, :protocols #{cljs.core/IWatchable cljs.core/IReset cljs.core/ISwap cljs.core/IMeta cljs.core/IDeref cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :name javelin.core/->Cell, :variadic false, :file "out/javelin/core.cljs", :end-column 14, :method-params ([meta state rank prev sources sinks thunk watches update constant numwatches]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 104, :end-line 104, :max-fixed-arity 11, :fn-var true, :arglists (quote ([meta state rank prev sources sinks thunk watches update constant numwatches])), :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IReset cljs.core/ISwap cljs.core/IMeta cljs.core/IDeref cljs.core/IPrintWithWriter cljs.core/IWithMeta}}, next-rank {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 38, :column 8, :end-line 38, :end-column 17, :private true, :arglists (quote ([]))}, :private true, :name javelin.core/next-rank, :variadic false, :file "out/javelin/core.cljs", :end-column 17, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 38, :end-line 38, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, input? {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 160, :column 7, :end-line 160, :end-column 13, :arglists (quote ([c]))}, :name javelin.core/input?, :variadic false, :file "out/javelin/core.cljs", :end-column 13, :method-params ([c]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 160, :end-line 160, :max-fixed-arity 1, :fn-var true, :arglists (quote ([c]))}, cell {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 201, :column 7, :end-line 201, :end-column 11, :arglists (quote ([x] [x & {:keys [meta]}])), :doc "Returns a new input cell containing value x. The :meta option can be used\n  to create the cell with the given metadata map.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([x]), :arglists ([x] [x & {:keys [meta]}]), :arglists-meta (nil nil)}}, :name javelin.core/cell, :variadic true, :file "out/javelin/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([x]), :arglists ([x] [x & {:keys [meta]}]), :arglists-meta (nil nil)}, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 201, :end-line 201, :max-fixed-arity 1, :fn-var true, :arglists ([x] [x & {:keys [meta]}]), :doc "Returns a new input cell containing value x. The :meta option can be used\n  to create the cell with the given metadata map."}, cell? {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 145, :column 7, :end-line 145, :end-column 12, :arglists (quote ([c])), :doc "Returns c if c is a Cell, nil otherwise."}, :name javelin.core/cell?, :variadic false, :file "out/javelin/core.cljs", :end-column 12, :method-params ([c]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 145, :end-line 145, :max-fixed-arity 1, :fn-var true, :arglists (quote ([c])), :doc "Returns c if c is a Cell, nil otherwise."}, destroy-cell! {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 47, :column 7, :end-line 47, :end-column 20, :arglists (quote ([this] [this keep-watches?])), :doc "Unlinks this Cell from the cell graph and resets all internal state. Watches\n  are preserved when keep-watches? is true, otherwise they are all removed.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([this] [this keep-watches?]), :arglists ([this] [this keep-watches?]), :arglists-meta (nil nil)}}, :name javelin.core/destroy-cell!, :variadic false, :file "out/javelin/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([this] [this keep-watches?]), :arglists ([this] [this keep-watches?]), :arglists-meta (nil nil)}, :method-params ([this] [this keep-watches?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 47, :end-line 47, :max-fixed-arity 2, :fn-var true, :arglists ([this] [this keep-watches?]), :doc "Unlinks this Cell from the cell graph and resets all internal state. Watches\n  are preserved when keep-watches? is true, otherwise they are all removed."}, last-rank {:name javelin.core/last-rank, :file "out/javelin/core.cljs", :line 19, :column 1, :end-line 19, :end-column 25, :private true, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 19, :column 16, :end-line 19, :end-column 25, :private true}, :tag any}, lift {:name javelin.core/lift, :file "out/javelin/core.cljs", :line 207, :column 1, :end-line 207, :end-column 23, :deprecated true, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 207, :column 19, :end-line 207, :end-column 23, :deprecated true}, :doc "This function is deprecated, please use #'javelin.core/formula instead."}, lens? {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 155, :column 7, :end-line 155, :end-column 12, :arglists (quote ([c]))}, :name javelin.core/lens?, :variadic false, :file "out/javelin/core.cljs", :end-column 12, :method-params ([c]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 155, :end-line 155, :max-fixed-arity 1, :fn-var true, :arglists (quote ([c]))}, set-formula! {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 87, :column 7, :end-line 87, :end-column 19, :arglists (quote ([this] [this f] [this f sources] [this f sources updatefn])), :doc "Given a Cell and optional formula function f and the cells f depends on,\n  sources, updates the formula for this cell in place. If f and/or sources\n  is not spcified they are set to nil.", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([this] [this f] [this f sources] [this f sources updatefn]), :arglists ([this] [this f] [this f sources] [this f sources updatefn]), :arglists-meta (nil nil nil nil)}}, :name javelin.core/set-formula!, :variadic false, :file "out/javelin/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([this] [this f] [this f sources] [this f sources updatefn]), :arglists ([this] [this f] [this f sources] [this f sources updatefn]), :arglists-meta (nil nil nil nil)}, :method-params ([this] [this f] [this f sources] [this f sources updatefn]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 87, :end-line 87, :max-fixed-arity 4, :fn-var true, :arglists ([this] [this f] [this f sources] [this f sources updatefn]), :doc "Given a Cell and optional formula function f and the cells f depends on,\n  sources, updates the formula for this cell in place. If f and/or sources\n  is not spcified they are set to nil."}, constant? {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 165, :column 7, :end-line 165, :end-column 16, :arglists (quote ([c]))}, :name javelin.core/constant?, :variadic false, :file "out/javelin/core.cljs", :end-column 16, :method-params ([c]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 165, :end-line 165, :max-fixed-arity 1, :fn-var true, :arglists (quote ([c]))}, add-sync! {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 41, :column 8, :end-line 41, :end-column 17, :private true, :arglists (quote ([c]))}, :private true, :name javelin.core/add-sync!, :variadic false, :file "out/javelin/core.cljs", :end-column 17, :method-params ([c]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 41, :end-line 41, :max-fixed-arity 1, :fn-var true, :arglists (quote ([c]))}, cmp-rank {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 39, :column 8, :end-line 39, :end-column 16, :private true, :arglists (quote ([a b]))}, :private true, :name javelin.core/cmp-rank, :variadic false, :file "out/javelin/core.cljs", :end-column 16, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 39, :end-line 39, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, cell-doseq* {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 266, :column 7, :end-line 266, :end-column 18, :arglists (quote ([c f])), :doc "Given a function f and a cell c that contains a seqable collection of items,\n  calls f for side effects once for each item in c, passing one argument: a\n  formula cell equivalent to (cell= (nth c i)) for the ith item in c. Whenever\n  c grows beyond its previous maximum size f is called as above for each item\n  beyond the maximum size. Nothing happens when c shrinks.\n\n  See also: the javelin.core/cell-doseq macro.\n\n  Consider:\n\n      (def things (cell [:a :b :c]))\n      (cell-doseq*\n        things\n        (fn doit [x]\n          (prn :creating @x)\n          (add-watch x nil #(prn :updating %3 %4))))\n\n      ;; the following is printed:\n\n      :creating :a\n      :creating :b\n      :creating :c\n\n  Shrink things by removing the last item:\n\n      (swap! things pop)\n\n      ;; the following is printed (because the 3rd item in things is now nil,\n      ;; since things only contains 2 items) -- note that the doit function is\n      ;; not called (or we would see a :creating message):\n\n      :updating :c nil\n\n  Grow things such that it is one item larger than it ever was:\n\n      (swap! things into [:u :v])\n\n      ;; the following is printed (because things now has 4 items, so the 3rd\n      ;; item is now :u and the max size increases by one with the new item :v):\n\n      :updating nil :u\n      :creating :v\n\n  A weird imagination is most useful to gain full advantage of all the features."}, :name javelin.core/cell-doseq*, :variadic false, :file "out/javelin/core.cljs", :end-column 18, :method-params ([c f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 266, :end-line 266, :max-fixed-arity 2, :fn-var true, :arglists (quote ([c f])), :doc "Given a function f and a cell c that contains a seqable collection of items,\n  calls f for side effects once for each item in c, passing one argument: a\n  formula cell equivalent to (cell= (nth c i)) for the ith item in c. Whenever\n  c grows beyond its previous maximum size f is called as above for each item\n  beyond the maximum size. Nothing happens when c shrinks.\n\n  See also: the javelin.core/cell-doseq macro.\n\n  Consider:\n\n      (def things (cell [:a :b :c]))\n      (cell-doseq*\n        things\n        (fn doit [x]\n          (prn :creating @x)\n          (add-watch x nil #(prn :updating %3 %4))))\n\n      ;; the following is printed:\n\n      :creating :a\n      :creating :b\n      :creating :c\n\n  Shrink things by removing the last item:\n\n      (swap! things pop)\n\n      ;; the following is printed (because the 3rd item in things is now nil,\n      ;; since things only contains 2 items) -- note that the doit function is\n      ;; not called (or we would see a :creating message):\n\n      :updating :c nil\n\n  Grow things such that it is one item larger than it ever was:\n\n      (swap! things into [:u :v])\n\n      ;; the following is printed (because things now has 4 items, so the 3rd\n      ;; item is now :u and the max size increases by one with the new item :v):\n\n      :updating nil :u\n      :creating :v\n\n  A weird imagination is most useful to gain full advantage of all the features."}, *tx* {:meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 18, :column 26, :end-line 18, :end-column 30, :dynamic true, :private true}, :private true, :name javelin.core/*tx*, :file "out/javelin/core.cljs", :end-column 30, :column 1, :dynamic true, :line 18, :end-line 18, :tag clj-nil}, deref* {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 33, :column 7, :end-line 33, :end-column 13, :arglists (quote ([x])), :doc "If x is a Cell dereferences x and returns the value, otherwise returns x."}, :name javelin.core/deref*, :variadic false, :file "out/javelin/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 33, :end-line 33, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is a Cell dereferences x and returns the value, otherwise returns x."}, propagate! {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 43, :column 8, :end-line 43, :end-column 18, :private true, :arglists (quote ([c]))}, :private true, :name javelin.core/propagate!, :variadic false, :file "out/javelin/core.cljs", :end-column 18, :method-params ([c]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 43, :end-line 43, :max-fixed-arity 1, :fn-var true, :arglists (quote ([c]))}, set-formula!* {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 64, :column 8, :end-line 64, :end-column 21, :private true, :arglists (quote ([this f sources updatefn]))}, :private true, :name javelin.core/set-formula!*, :variadic false, :file "out/javelin/core.cljs", :end-column 21, :method-params ([this f sources updatefn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 64, :end-line 64, :max-fixed-arity 4, :fn-var true, :arglists (quote ([this f sources updatefn]))}, set-cell! {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 170, :column 7, :end-line 170, :end-column 16, :arglists (quote ([c x])), :doc "Converts c to an input cell in place, setting its contents to x. It's okay\n  if c was already an input cell. Changes will be propagated to any cells that\n  depend on c."}, :name javelin.core/set-cell!, :variadic false, :file "out/javelin/core.cljs", :end-column 16, :method-params ([c x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 170, :end-line 170, :max-fixed-arity 2, :fn-var true, :arglists (quote ([c x])), :doc "Converts c to an input cell in place, setting its contents to x. It's okay\n  if c was already an input cell. Changes will be propagated to any cells that\n  depend on c."}, lens {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 195, :column 7, :end-line 195, :end-column 11, :arglists (quote ([c f])), :doc "Returns a new lens whose value is the same as c's with update function f.\n  This is equivalent to ((formula identity f) c)."}, :name javelin.core/lens, :variadic false, :file "out/javelin/core.cljs", :end-column 11, :method-params ([c f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 195, :end-line 195, :max-fixed-arity 2, :fn-var true, :arglists (quote ([c f])), :doc "Returns a new lens whose value is the same as c's with update function f.\n  This is equivalent to ((formula identity f) c)."}, formula? {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 150, :column 7, :end-line 150, :end-column 15, :arglists (quote ([c]))}, :name javelin.core/formula?, :variadic false, :file "out/javelin/core.cljs", :end-column 15, :method-params ([c]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 150, :end-line 150, :max-fixed-arity 1, :fn-var true, :arglists (quote ([c]))}, propagate* {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 21, :column 8, :end-line 21, :end-column 18, :private true, :arglists (quote ([pri-map]))}, :private true, :name javelin.core/propagate*, :variadic false, :file "out/javelin/core.cljs", :end-column 18, :method-params ([pri-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 21, :end-line 21, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pri-map]))}, Cell {:meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 16, :column 10, :end-line 16, :end-column 14, :declared true}, :num-fields 11, :protocols #{cljs.core/IWatchable cljs.core/IReset cljs.core/ISwap cljs.core/IMeta cljs.core/IDeref cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :name javelin.core/Cell, :file "out/javelin/core.cljs", :end-column 14, :type true, :column 10, :line 104, :record false, :declared true, :end-line 104, :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IReset cljs.core/ISwap cljs.core/IMeta cljs.core/IDeref cljs.core/IPrintWithWriter cljs.core/IWithMeta}}, alts! {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 229, :column 7, :end-line 229, :end-column 12, :arglists (quote ([& cells])), :doc "Given a number of cells, returns a formula cell whose value is a seq of\n  values from cells that changed in the last update. Note that multiple cells\n  may update atomically, which is why the formula's value is a seq.\n\n  Consider:\n\n      (def a (cell {:x 1 :y 2}))\n      (def x (cell= (:x a)))\n      (def y (cell= (:y a)))\n      (def z (alts! x y))\n\n  then,\n\n      (deref z) ;=> (1 2)\n\n      (swap! a assoc :x 42)\n      (deref z) ;=> (42)\n\n      (reset! a {:x 10 :y 20})\n      (deref z) ;=> (10 20)\n  ", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(cells)], :arglists ([& cells]), :arglists-meta (nil)}}, :name javelin.core/alts!, :variadic true, :file "out/javelin/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(cells)], :arglists ([& cells]), :arglists-meta (nil)}, :method-params [(cells)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 229, :end-line 229, :max-fixed-arity 0, :fn-var true, :arglists ([& cells]), :doc "Given a number of cells, returns a formula cell whose value is a seq of\n  values from cells that changed in the last update. Note that multiple cells\n  may update atomically, which is why the formula's value is a seq.\n\n  Consider:\n\n      (def a (cell {:x 1 :y 2}))\n      (def x (cell= (:x a)))\n      (def y (cell= (:y a)))\n      (def z (alts! x y))\n\n  then,\n\n      (deref z) ;=> (1 2)\n\n      (swap! a assoc :x 42)\n      (deref z) ;=> (42)\n\n      (reset! a {:x 10 :y 20})\n      (deref z) ;=> (10 20)\n  "}, dosync* {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 213, :column 7, :end-line 213, :end-column 14, :arglists (quote ([thunk])), :doc "Calls the thunk with no arguments within a transaction. Propagation of\n  updates to formula cells is deferred until the transaction is complete.\n  Input cells *will* update during the transaction. Transactions may be\n  nested.\n\n  See also: the javelin.core/dosync macro."}, :name javelin.core/dosync*, :variadic false, :file "out/javelin/core.cljs", :end-column 14, :method-params ([thunk]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 213, :end-line 213, :max-fixed-arity 1, :fn-var true, :arglists (quote ([thunk])), :doc "Calls the thunk with no arguments within a transaction. Propagation of\n  updates to formula cells is deferred until the transaction is complete.\n  Input cells *will* update during the transaction. Transactions may be\n  nested.\n\n  See also: the javelin.core/dosync macro."}, cell-map {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 258, :column 7, :end-line 258, :end-column 15, :arglists (quote ([f c])), :doc "Given a function f and a cell c that contains a seqable collection of items,\n  returns a seq of formula cells such that the ith formula cell is equivalent\n  to (cell= (f (nth c i)))."}, :name javelin.core/cell-map, :variadic false, :file "out/javelin/core.cljs", :end-column 15, :method-params ([f c]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 258, :end-line 258, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f c])), :doc "Given a function f and a cell c that contains a seqable collection of items,\n  returns a seq of formula cells such that the ith formula cell is equivalent\n  to (cell= (f (nth c i)))."}, safe-nth {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 42, :column 8, :end-line 42, :end-column 16, :private true, :arglists (quote ([c i]))}, :private true, :name javelin.core/safe-nth, :variadic false, :file "out/javelin/core.cljs", :end-column 16, :method-params ([c i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 42, :end-line 42, :max-fixed-arity 2, :fn-var true, :arglists (quote ([c i]))}, formula {:protocol-inline nil, :meta {:file "/Users/kennetht2/todoFRP/todo/MatrixCLJS/out/javelin/core.cljs", :line 177, :column 7, :end-line 177, :end-column 14, :arglists (quote ([f] [f updatefn])), :doc "Returns a function that returns a formula cell with f as its formula, and\n  if updatefn is provided the returned cell is a lens.\n\n  See also: the javelin.core/cell= macro.\n\n      (def x (cell 100))\n      (def y (cell 200))\n\n      (def z1 (cell= (+ x y)))\n      (def z2 ((formula +) x y))\n\n  The formula cells z1 and z2 are equivalent.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f updatefn]), :arglists ([f] [f updatefn]), :arglists-meta (nil nil)}}, :name javelin.core/formula, :variadic false, :file "out/javelin/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f updatefn]), :arglists ([f] [f updatefn]), :arglists-meta (nil nil)}, :method-params ([f] [f updatefn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 177, :end-line 177, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f updatefn]), :doc "Returns a function that returns a formula cell with f as its formula, and\n  if updatefn is provided the returned cell is a lens.\n\n  See also: the javelin.core/cell= macro.\n\n      (def x (cell 100))\n      (def y (cell 200))\n\n      (def z1 (cell= (+ x y)))\n      (def z2 ((formula +) x y))\n\n  The formula cells z1 and z2 are equivalent."}}, :cljs.spec/registry-ref [], :require-macros {javelin.core javelin.core}, :cljs.analyzer/constants {:seen #{:javelin.core/none :meta :else watches meta sinks numwatches sources constant rank update thunk state prev}, :order [:else meta state rank prev sources sinks thunk watches update constant numwatches :javelin.core/none :meta]}, :doc nil}